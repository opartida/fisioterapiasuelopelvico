<?php

/**
 * @file
 * EU Cookie Compliance Extras primary module file.
 *
 * This modules provides a performant consent storage plugin for the
 * EU Cookie Compliance module and integrations with popular modules
 * that store cookies to the end user's browser.
 *
 * Author: Thomas Minitsios
 */

/**
 * Implements hook_help().
 */
function euccx_help($path, $arg) {
  switch ($path) {
    case 'admin/help#euccx':

      $filepath = dirname(__FILE__) . '/README.md';
      if (file_exists($filepath)) {
        $readme = file_get_contents($filepath);
      }
      else {
        $filepath = dirname(__FILE__) . '/README.txt';
        if (file_exists($filepath)) {
          $readme = file_get_contents($filepath);
        }
      }
      if (!isset($readme)) {
        return NULL;
      }
      if (module_exists('markdown')) {
        $filters = module_invoke('markdown', 'filter_info');
        $info = $filters['filter_markdown'];

        if (function_exists($info['process callback'])) {
          $output = $info['process callback']($readme, NULL);
        }
        else {
          $output = '<pre>' . $readme . '</pre>';
        }
      }
      else {
        $output = '<pre>' . $readme . '</pre>';
      }

      return $output;
  }
}

/**
 * Implements hook_variable_info().
 */
function euccx_variable_info($options = array()) {
  $variables['euccx'] = array(
    'title' => t('EU Cookie Compliance Extras'),
    'description' => t('Settings for the euccx module'),
    'type' => 'array',
    'access' => 'administer EU Cookie Compliance popup',
    'localize' => TRUE,
    'multidomain' => TRUE,
  );

  return $variables;
}

/**
 * Implements hook_menu().
 */
function euccx_menu() {
  // We create an extra admin settings' form for our settings and the settings
  // of any custom plugins that are created.
  $items['admin/config/system/eu-cookie-compliance/extras'] = array(
    'title' => 'EU Cookie Compliance Extras',
    'type' => MENU_LOCAL_ACTION,
    'description' => 'Extra Options and Integrations for the EU Cookie Compliance module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('euccx_admin_form'),
    'access arguments' => array('administer EU Cookie Compliance popup'),
    'file' => 'euccx.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_block_info().
 *
 * Register our block(s).
 */
function euccx_block_info() {
  $blocks = array();

  $blocks['euccx_cookie_settings'] = array(
    'info' => t('EU Cookie Compliance Extras'),
    // @todo: revisit this and probably switch to DRUPAL_CACHE_CUSTOM after we
    // know what we want to do when it comes to caching for this block
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_preprocess_hook().
 *
 * We use preprocess html to add our blocking scripts at the top of the head
 * if the user has not given their consent yet.
 * The reason why we're not using preprocess_page instead, is that in cases
 * where panels_everywhere is used, the page is not executed.
 */
function euccx_preprocess_html(&$variables) {
  ctools_include('plugins');

  $cookie_consent_plugins = ctools_get_plugins('euccx', 'cookie_consent');

  $blacklists = array();

  foreach ($cookie_consent_plugins as $plugin_name => $plugin_settings) {
    // Check if the specific plugin is enabled.
    $plugin_enabled = _euccx_settings($plugin_name, 0, '', $plugin_name);
    if (empty($plugin_enabled)) {
      continue;
    }
    // Check if the specific plugin has defined a blacklist.
    if (empty($plugin_settings['blacklist'])) {
      continue;
    }

    foreach ($plugin_settings['blacklist'] as $blacklisted_item) {
      $blacklists[] = $blacklisted_item;
    }
  }

  // Javascript Part that handles the blacklists (if they exist)
  if (!empty($blacklists)) {
    $blacklist = implode(", ", $blacklists);
    $yett = '<script type="text/javascript">window.YETT_BLACKLIST = [';
    $yett .= $blacklist;
    $yett .= '];</script><script type="text/javascript" src="/';
    $yett .= drupal_get_path('module', 'euccx') . '/js/yett.min.js';
    $yett .= '"></script>';

    $yett_renderable = array(
      '#type' => 'markup',
      '#markup' => $yett,
    );

    // Use drupal_add_html_head() instead of adding the scripts somewhere with
    // #attached because we do not want these scripts to be aggregated and be
    // added somewhere along the long chain of scripts. Adsense prints scripts
    // at the top of the page and we need to print ours before that in order to
    // block it from loading them until the user gives consent.
    drupal_add_html_head($yett_renderable, 'yett');
  }

  // Create a function per plugin that contains all the javascript code that was
  // disabled (by the plugin) through hook_js_alter.
  $disabled_javascripts = variable_get('euccx_dj', array());

  if (empty($disabled_javascripts['disabled_javascripts'])) {
    return;
  }

  $disabled_javascripts = $disabled_javascripts['disabled_javascripts'];

  foreach ($disabled_javascripts as $plugin_name => $djdata) {
    $scripts = '';

    foreach ($djdata as $script_name => $script) {
      if (empty($script['type'])) {
        continue;
      }
      if ($script['type'] === 'file') {
        $source = "/" . $script_name;
        $scripts .= 'var scriptTag = document.createElement("script");';
        $scripts .= 'scriptTag.src = ' . drupal_json_encode($source) . ';';
        $scripts .= 'document.body.appendChild(scriptTag);';
      }
      elseif ($script['type'] === 'inline') {
        // If the user enters a multiline piece of javascript, we need to make
        // sure that we remove the newline characters before we append it in the
        // text attribute of our script.
        $fixed_code = str_replace(array("\n", "\r"), '', $script['data']);
        // We also need to make sure that we replace any single quotes with
        // double quotes so that we don't mess up with our javascript which
        // encloses everything in single quotes.
        $fixed_code = str_replace("'", '"', $fixed_code);
        $scripts .= 'var scriptTag = document.createElement("script");';
        $scripts .= 'scriptTag.text = ';
        $scripts .= "'" . $fixed_code . "';";
        $scripts .= 'document.body.appendChild(scriptTag);';

      }
    }

    $js_to_load = 'function euccx' . $plugin_name . 'Load() {' . $scripts . '}';
    $js_to_load = '<script type="text/javascript">' . $js_to_load . "</script>";
    $script_key = $plugin_name;
    $js_to_load = array(
      '#type' => 'markup',
      '#markup' => $js_to_load,
    );
    drupal_add_html_head($js_to_load, $script_key);
  }
}

/**
 * Implements hook_js_alter().
 *
 * We need to support the js_exclude plugin option.
 */
function euccx_js_alter(&$js) {
  ctools_include('plugins');

  $cookie_consent_plugins = ctools_get_plugins('euccx', 'cookie_consent');

  // Create an array to store all the javascripts that we are disabling so that
  // we can re-enable them in the front end when it's appropriate.
  $disabled_javascripts = array();

  foreach ($cookie_consent_plugins as $plugin_name => $plugin_settings) {
    // We need to check if the plugin is enabled and if it uses js_exclude.
    $is_enabled_setting = _euccx_settings($plugin_name, '', '', $plugin_name);
    $is_enabled = !empty($is_enabled_setting);
    $has_js_exclude = !empty($plugin_settings['js_exclude']);

    if ($is_enabled && $has_js_exclude) {
      $names = $plugin_settings['js_exclude']['name'];
      $data = $plugin_settings['js_exclude']['data'];
      foreach ($js as $key => $value) {
        if (_euccx_multi_search($key, $names)) {
          $disabled_javascripts[$plugin_name][$key] = $value;
          unset($js[$key]);
          // We need to continue so that we only unset things once.
          continue;
        }
        // We need to make sure that the data exists, is a string (not an array
        // like in settings for example) and contains any of our terms in order
        // to unset the javascript entry.
        if (!empty($value['data']) &&
          is_string($value['data']) &&
          _euccx_multi_search($value['data'], $data)) {
          $disabled_javascripts[$plugin_name][$key] = $value;
          unset($js[$key]);
        }
      }
    }
  }

  // Add the javascripts that we disabled in our module in a variable that we
  // can export for our page builder to use.
  $euccx = variable_get('euccx_dj', array());
  $euccx['disabled_javascripts'] = $disabled_javascripts;
  variable_set('euccx_dj', $euccx);
}

/**
 * Implements hook_block_view().
 *
 * Determine how our block(s) will be rendered.
 */
function euccx_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'euccx_cookie_settings':
      $block['subject'] = t('Cookie Settings');
      $block['content'] = _euccx_cookie_settings_gen();
      break;
  }

  return $block;
}

/**
 * Generates the renderable array for our block.
 */
function _euccx_cookie_settings_gen() {
  $output = array();

  $theme_vars = _euccx_get_block_theme_vars();

  $output['#markup'] = theme('euccx_block', $theme_vars);
  $output['#attached'] = array();

  // If the user left the "minimal css" empty, we add our css file.
  if (empty($theme_vars['bare_css'])) {
    $output['#attached']['css'] = array(
      drupal_get_path('module', 'euccx') . '/css/euccx.css',
    );
  }

  $output['#attached']['library'] = array(
    array('system', 'ui.tabs'),
  );

  return $output;
}

/**
 * Helper function to get an aray of the available theme vars for block.
 */
function _euccx_get_block_theme_vars() {
  // Is EUCC opt-in with categories used? This has several implications for us:
  $uses_categories = _euccx_uses_categories();
  $euccx_var = variable_get('euccx', array());

  $rc_value = _euccx_settings('rctext', '', 'value');
  $rc_format = _euccx_settings('rctext', 'plain_text', 'format');
  $required_cookies_text = check_markup($rc_value, $rc_format);
  $rc_title = check_plain(_euccx_settings('rctitle', 'Required Cookies'));

  $required_cookies_toggle = theme('euccx_toggle_button', array(
    'title' => $rc_title,
    'has_input' => FALSE,
    'toggle_id' => 'required-cookies',
    'uses_categories' => $uses_categories,
  )
  );
  $required_cookies = $required_cookies_toggle . $required_cookies_text;

  $privacy_page_markup = _euccx_get_privacy_page_contents();
  $plugins = !empty($euccx_var['plugins']) ? $euccx_var['plugins'] : array();

  $plugin_arr = array();
  foreach ($plugins as $plugin_key => $plugin_array) {
    if ($plugin_array[$plugin_key]) {
      $plugin_arr[$plugin_key] = array();

      $group = $plugin_key . "_group";
      $title = check_plain($plugin_array[$group]['title']);
      $markup = "<li><a href='#$plugin_key'>$title</a></li>";

      $prefix = "<div id='$plugin_key'>";
      $toggle = theme('euccx_toggle_button', array(
        'title' => $title,
        // When using opt-in with categories, input is always disabled,
        // representing the selected categories status instead.
        'has_input' => !$uses_categories,
        'toggle_id' => $plugin_key,
        'uses_categories' => $uses_categories,
      )
      );
      $value = $plugin_array[$group]['content']['value'];
      $format = $plugin_array[$group]['content']['format'];
      $content = check_markup($value, $format);
      $suffix = "</div>";
      $full_content_markup = $prefix . $toggle . $content . $suffix;

      $plugin_arr[$plugin_key]['title'] = $markup;
      $plugin_arr[$plugin_key]['content'] = $full_content_markup;
    }
  }

  $save = _euccx_settings('save_button_text', 'Save my cookie preferences');
  $toggle_withdraw_banner_button_text = _euccx_settings('toggle_withdraw_banner_button_text', 'Change my cookie preferences');
  $ppt = _euccx_settings('pptitle', 'Privacy Policy');
  $rct = _euccx_settings('rctitle', 'Required Cookies');

  $theme_vars = array(
    'bare_css' => _euccx_settings('include_bare_css', 0),
    'save' => filter_xss($save),
    'privacy_page' => _euccx_settings('include_pp', 0),
    'privacy_page_title' => filter_xss($ppt),
    'privacy_page_contents' => filter_xss($privacy_page_markup),
    'required_cookies' => _euccx_settings('include_required', 0),
    'show_toggle' => _euccx_settings('rctoggle', 0),
    'required_cookies_title' => filter_xss($rct),
    'required_cookies_text' => $required_cookies,
    'plugins' => $plugin_arr,
    'uses_categories' => $uses_categories,
    'toggle_withdraw_banner_button_text' => check_plain($toggle_withdraw_banner_button_text),
  );

  return $theme_vars;
}

/**
 * Helper function that returns the privacy page contents.
 *
 * If the privacy page is not set in our settings or is set and is not a node,
 * return an empty string.
 */
function _euccx_get_privacy_page_contents() {
  $link = _euccx_settings('pplink', '');
  // For now we only support the node/$nid format.
  // @todo: Support all the tokens and stuff that the actual field in EU
  // Cookie Compliance module supports.
  preg_match('/(?<=node\/)\d*/', $link, $nids);
  // If the pattern was not found or if the node could not be load, the
  // following expression will return FALSE.
  $node = !empty($nids[0]) ? node_load($nids[0]) : FALSE;
  // If the privacy policy link has the default value (<front>) or if the
  // previous expression returned FALSE (because either the format was bad or
  // the node could not be loaded), we return an empty string.
  if (!$node) {
    return '';
  }

  // Always render with the 'full' view mode type.
  // @todo: Maybe allow for more and account for language?
  $node_array = node_view($node, 'full');

  // @todo: Is there a case where it is imperative that we don't do the
  // rendering here but on the template file end?
  return drupal_render($node_array);
}

/**
 * Implements hook_theme().
 *
 * We need to give our users the option to override how the block looks.
 */
function euccx_theme() {
  return array(
    'euccx_block' => array(
      'template' => 'euccx',
    ),
    'euccx_toggle_button' => array(
      'template' => 'euccx-toggle-button',
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 *
 * We need to include our highly performant consent storage plugin which
 * belongs in the "eu_cookie_compliance" namespace, along with our own plugins
 * to provide integrations with popular modules that store cookies in the end
 * user's browser.
 */
function euccx_ctools_plugin_directory($owner, $plugin_type) {
  if (($owner == 'eu_cookie_compliance' || $owner == 'euccx')
       && !empty($plugin_type)) {
    return "plugins/$plugin_type";
  }
}

/**
 * Implements hook_ctools_plugin_type().
 *
 * Define our own plugin type.
 */
function euccx_ctools_plugin_type() {
  $plugins = array();
  $plugins['cookie_consent'] = array();
  return $plugins;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * We need to alter the default settings' form of the EU Cookie Compliance
 * module in order to account for the new keys that we've allowed in the
 * plugin definition, namely: 'description', 'module_dependencies' and
 * 'consent_storage_extra_options_callback'. If our module is enabled, those
 * keys will be universally identified even if a completely different module
 * implements a consent_storage plugin.
 */
function euccx_form_eu_cookie_compliance_admin_form_alter(&$form, &$form_state) {
  ctools_include('plugins');

  $consent_storage_extra_options = array();
  $consent_storage_extra_form_elements = array();
  $consent_storage_plugins = ctools_get_plugins('eu_cookie_compliance', 'consent_storage');
  foreach ($consent_storage_plugins as $key => $consent_storage_plugin) {
    // Support the "description" key in the plugin definition
    // We handle this first because if there are any module dependencies which
    // render the plugin unusable, the description will be properly overwritten
    // with the more important message.
    if (!empty($consent_storage_plugin['description'])) {
      $consent_storage_extra_options[$key]['#description'] = $consent_storage_plugin['description'];
    }
    // Support the "module_dependencies" key in the plugin definition
    // If you declare an array of module dependencies for your storage plugin,
    // those dependencies will be properly respected.
    if (!empty($consent_storage_plugin['module_dependencies'])) {
      // Keep a string with all the dependencies that are not met so that the
      // message printed to the user is actually helpful.
      $module_dependency_string = '';
      foreach ($consent_storage_plugin['module_dependencies'] as $module_dependency) {
        if (!module_exists($module_dependency)) {
          // Add the new unmet dependency to the string that will be
          // printed to the user.
          $module_dependency_string = empty($module_dependency_string) ? $module_dependency : "$module_dependency_string, $module_dependency";
          $consent_storage_extra_options[$key]['#disabled'] = TRUE;
          $consent_storage_extra_options[$key]['#description'] = t('You need to enable: <strong>%dependencies</strong> module(s) in order to use this storage', array('%dependencies' => $module_dependency_string));
        }
      }
    }
    // Fill in our variable with the extra form elements.
    if (!empty($consent_storage_plugin['consent_storage_extra_options_callback'])) {
      $consent_storage_extra_form_elements[$key] = $consent_storage_plugin['consent_storage_extra_options_callback']();
    }
  }
  // Add extra storage options: this is used to display a helpful description
  // for each storage plugin that has one, but also to disable storage options
  // that depend on specific modules and print a helpful description so that the
  // user always knows why the storage option is not available.
  if (!empty($consent_storage_extra_options)) {
    foreach ($consent_storage_extra_options as $extra_option_key => $consent_storage_extra_option) {
      $form['consent_storage']['eu_cookie_compliance']['consent_storage_method'][$extra_option_key] = $consent_storage_extra_option;
    }
  }

  foreach ($consent_storage_extra_form_elements as $key => $element) {
    // We need a "grouping item" so that we can hide all the different options
    // at once if the corresponding storage plugin is not selected.
    $form['consent_storage']['eu_cookie_compliance'][$key] = array(
      '#type' => 'item',
      '#tree' => TRUE,
      '#states' => array(
        'visible' => array(
          ':input[name="eu_cookie_compliance[consent_storage_method]"]' => array('value' => $key),
        ),
      ),
    );

    foreach ($element as $subkey => $item) {
      $form['consent_storage']['eu_cookie_compliance'][$key][$subkey] = $item;
    }
  }

}

/**
 * Implements hook_page_alter().
 *
 * Add our plugin and module settings in the javascript of the page.
 */
function euccx_page_alter(&$page) {
  ctools_include('plugins');

  $cookie_consent_plugins = ctools_get_plugins('euccx', 'cookie_consent');
  $module_settings = variable_get('euccx', array());

  // If there were actual module settings saved by the user, loop through them.
  if (!empty($module_settings)) {
    // Loop through the module settings to see which plugins are not enabled so
    // that we can remove them from consideration.
    foreach ($module_settings['plugins'] as $key => $value) {
      // If the plugin is disabled in the administration interface, remove it
      // from the array of settings that we expose to javascript.
      if (empty($value[$key])) {
        unset($cookie_consent_plugins[$key]);
        unset($module_settings['plugins'][$key]);
      }
    }
  }

  // Do some extra processing to the variable that we expose to javascript since
  // we only have the full picture in the backend.
  $psettings = _euccx_spice_plugins_up($cookie_consent_plugins);
  $settings = array(
    'plugins' => $psettings,
  );

  // We need to know if the user has selected the boxes to be pre-ticked or not
  // on the javascript end. So we need to add another setting.
  // For more information about this check the related option in the admin
  // interface.
  $settings['unticked'] = _euccx_settings('unticked', 0);

  // We also need to know if the "disable all" button is enabled or not.
  $settings['dab'] = _euccx_settings('disable_all_button', 0);

  // Add the names of our plugins in the Javascript settings.
  $page['content']['#attached']['js'][] = array(
    'data' => array('euccx' => $settings),
    'type' => 'setting',
  );

  drupal_add_library('system', 'jquery.cookie');

  // Add our javascript file in the page render array.
  $page['content']['#attached']['js'][] = array(
    'data' => drupal_get_path('module', 'euccx') . '/js/euccx.js',
    'type' => 'file',
    'group' => JS_DEFAULT,
    'scope' => 'footer',
  );
}

/**
 * Helper function which returns true, if EUCC uses categories as opt-in
 * method. This has several larger implications for us.
 *
 * https://www.drupal.org/project/euccx/issues/3144073
 *
 * @return boolean
 */
function _euccx_uses_categories() {
  module_load_include('module', 'eu_cookie_compliance');
  // Get the EUCC settings.
  $eucc_settings = eu_cookie_compliance_get_settings();
  return $method_is_categories = $eucc_settings['method'] == 'categories';
}

/**
 * Helper function to return the EUCC opt-in categories.
 *
 * @return array
 */
function _euccx_get_categories() {
  module_load_include('module', 'eu_cookie_compliance');
  $eucc_settings = eu_cookie_compliance_get_settings();
  return $eucc_settings['cookie_categories'];
}

/**
 * Helper function to return the opt-in categories as FAPI array for select
 * options.
 *
 * @return array
 */
function _euccx_get_categories_options() {
  module_load_include('module', 'eu_cookie_compliance');
  $cookie_categories = _eu_cookie_compliance_extract_category_key_label_description(_euccx_get_categories());
  $cookie_categories_options = array();
  if (!empty($cookie_categories)) {
    foreach($cookie_categories as $key => $cookie_category){
      $cookie_categories_options[$key] = $cookie_category['label'];
    }
  }
  return $cookie_categories_options;
}

/**
 * Helper function to add some extra information in the plugin settings.
 *
 * This function also removes information that the front-end does not need like
 * the path to the plugin, the names of the callback functions etc.
 */
function _euccx_spice_plugins_up($plugins) {
  $output = array();
  foreach ($plugins as $plugin_name => $plugin) {
    $output[$plugin_name] = array();
    // Process the text that will be displayed to the user using the appropriate
    // text format.
    if (!empty($plugin['module_block_overrides'])) {
      $output[$plugin_name]['overrides'] = array();
      foreach ($plugin['module_block_overrides'] as $overrides) {
        $setting = $overrides['setting'];
        $selector = $overrides['selector'];
        // Process the output based on the textarea's settings.
        $mbo_value = _euccx_settings($setting, '', 'value', $plugin_name);
        $mbo_format = _euccx_settings(
          $setting,
          'plain_text',
          'format',
          $plugin_name
        );
        $mbo_text = check_markup($mbo_value, $mbo_format);

        $output[$plugin_name]['overrides'][$selector] = $mbo_text;
      }

    }
    // The "blacklist", "js_exclude" and "cookies_handled" keys that are
    // supported through the plugin system can easily be exported as they are.
    // Blacklist.
    if (!empty($plugin['blacklist'])) {
      $output[$plugin_name]['blacklist'] = $plugin['blacklist'];
    }
    // Js_exclude.
    if (!empty($plugin['js_exclude'])) {
      $output[$plugin_name]['js_exclude'] = $plugin['js_exclude'];
    }
    // Cookies_handled.
    if (!empty($plugin['cookies_handled'])) {
      $output[$plugin_name]['cookies_handled'] = $plugin['cookies_handled'];
    }
    // Add opt_in_category, if used:
    $opt_in_category = _euccx_settings(
      'opt_in_category',
      FALSE,
      '',
      $plugin_name
    );
    if(!empty($opt_in_category)){
      $output[$plugin_name]['opt_in_category'] = check_plain($opt_in_category);
    }
  }
  return $output;
}

/**
 * Helper function.
 *
 * Treats a string as a haystack and an array of strings as needles. If any of
 * the needles are found in the haystack, it returns TRUE otherwise FALSE.
 */
function _euccx_multi_search($haystack, array $needles, $csensitive = TRUE) {
  foreach ($needles as $needle) {
    $check = $csensitive ?
      strpos($haystack, $needle) :
      stripos($haystack, $needle);

    if ($check !== FALSE) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Helper function.
 *
 * Given a setting name and optionally a key and a context, returns the correct
 * value to be used in the "#default_value" key of the admin form. If not
 * provided with a default value, this function will return NULL.
 *
 * @param string $setting
 *   Setting to retrieve.
 * @param string|null $default
 *   A default value to return if no setting is found.
 * @param string $key
 *   Some fields require an extra key (e.g. text_format has 'value' and
 *   'format').
 * @param string $context
 *   Used for external plugins to prevent confusion in case settings from two
 *   different plugins happen to share the same name.
 *
 * @return string|null|array
 *   If no settings are found and no default value is provided, this function
 *   will return NULL.
 */
function _euccx_settings($setting, $default = NULL, $key = '', $context = '') {
  $settings = variable_get('euccx', array());

  // If there is a context, make sure to just traverse the specific plugin.
  if (!empty($context)) {
    if (isset($settings['plugins'][$context])) {
      // ... else there is no need to traverse the plugins' settings.
      $settings = $settings['plugins'][$context];
    }
    else {
      // The user did not supply a proper context.
      return isset($default) ? $default : NULL;
    }
  }
  else {
    if (isset($settings['plugins'])) {
      unset($settings['plugins']);
    }
    // ... else we don't have to deal with plugins.
  }

  $found = _euccx_array_search($settings, $setting);
  if (isset($found) && !empty($key)) {
    return isset($found[$key]) ? $found[$key] : $default;
  }

  return isset($found) ? $found : $default;
}

/**
 * Helper function.
 *
 * Given a multi-dimensional array and a key, returns the value of the key
 * (recursively).
 *
 * @param array $haystack
 *   The array to search in.
 * @param string $needle
 *   They key to find.
 *
 * @return string|null|array
 *   Returns NULL if nothing is found.
 */
function _euccx_array_search(array $haystack, $needle) {
  $arrayIterator = new RecursiveArrayIterator($haystack);
  $flat = new RecursiveIteratorIterator(
    $arrayIterator,
    RecursiveIteratorIterator::SELF_FIRST
  );

  foreach ($flat as $key => $value) {
    if ($key == $needle) {
      return $value;
    }
  }

  return NULL;
}
